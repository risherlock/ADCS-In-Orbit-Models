#include <math.h>
#include "maps.h"

void quat_to_dcm(const double q[4], double r[3][3])
{
  r[0][0] = q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3];
  r[0][1] = 2.0 * (q[1] * q[2] + q[0] * q[3]);
  r[0][2] = 2.0 * (q[1] * q[3] - q[0] * q[2]);
  r[1][0] = 2.0 * (q[1] * q[2] - q[0] * q[3]);
  r[1][1] = q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3];
  r[1][2] = 2.0 * (q[2] * q[3] + q[0] * q[1]);
  r[2][0] = 2.0 * (q[1] * q[3] + q[0] * q[2]);
  r[2][1] = 2.0 * (q[2] * q[3] - q[0] * q[1]);
  r[2][2] = q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3];
}

void dcm_to_quat(const double r[3][3], double q[4])
{
  double trace = r[0][0] + r[1][1] + r[2][2];
  double s;

  if (trace > 0)
  {
    s = 2.0 * sqrt(1.0 + trace);
    q[0] = 0.25 * s;
    q[1] = (r[2][1] - r[1][2]) / s;
    q[2] = (r[0][2] - r[2][0]) / s;
    q[3] = (r[1][0] - r[0][1]) / s;
  }
  else
  {
    if (r[0][0] > r[1][1] && r[0][0] > r[2][2])
    {
      s = 2.0 * sqrt(1.0 + r[0][0] - r[1][1] - r[2][2]);
      q[0] = (r[2][1] - r[1][2]) / s;
      q[1] = 0.25 * s;
      q[2] = (r[0][1] + r[1][0]) / s;
      q[3] = (r[0][2] + r[2][0]) / s;
    }
    else if (r[1][1] > r[2][2])
    {
      s = 2.0 * sqrt(1.0 + r[1][1] - r[0][0] - r[2][2]);
      q[0] = (r[0][2] - r[2][0]) / s;
      q[1] = (r[0][1] + r[1][0]) / s;
      q[2] = 0.25 * s;
      q[3] = (r[1][2] + r[2][1]) / s;
    }
    else
    {
      s = 2.0 * sqrt(1.0 + r[2][2] - r[0][0] - r[1][1]) * 2;
      q[0] = (r[1][0] - r[0][1]) / s;
      q[1] = (r[0][2] + r[2][0]) / s;
      q[2] = (r[1][2] + r[2][1]) / s;
      q[3] = 0.25 * s;
    }
  }
}

void quat_to_euler(const double q[4], double e[3], const euler_seq_t es)
{
  double q2_sq = q[2] * q[2];
  e[0] = atan2(2.0 * (q[0] * q[1] + q[2] * q[3]), 1.0 - 2.0 * (q[1] * q[1] + q2_sq));
  e[2] = atan2(2.0 * (q[0] * q[3] + q[1] * q[2]), 1.0 - 2.0 * (q2_sq + q[3] * q[3]));

  double sin_e1 = 2.0 * (q[0] * q[2] - q[1] * q[3]);

  if (fabs(sin_e1) >= 1.0)
  {
    e[1] = copysign(M_PI_2, sin_e1);
  }
  else
  {
    e[1] = asin(sin_e1);
  }
}

void euler_to_quat(const double e[3], const euler_seq_t es, double q[3])
{
  const double c[3] = {cos(0.5 * e[0]), cos(0.5 * e[1]), cos(0.5 * e[2])};
  const double s[3] = {sin(0.5 * e[0]), sin(0.5 * e[1]), sin(0.5 * e[2])};
  const double h[3] = {0.5 * e[0], 0.5 * e[1], 0.5 * e[2]};
  const double ch = cos(h[1]);
  const double sh = sin(h[1]);

  switch (es)
  {
  case EULER_123:
  {
    q[0] = c[0] * c[1] * c[2] - s[0] * s[1] * s[2];
    q[1] = s[0] * c[1] * c[2] + c[0] * s[1] * s[2];
    q[2] = c[0] * s[1] * c[2] - s[0] * c[1] * s[2];
    q[3] = c[0] * c[1] * s[2] + s[0] * s[1] * c[2];
    break;
  }

  case EULER_132:
  {
    q[0] = c[0] * c[1] * c[2] + s[0] * s[1] * s[2];
    q[1] = s[0] * c[1] * c[2] - c[0] * s[1] * s[2];
    q[2] = c[0] * c[1] * s[2] - s[0] * s[1] * c[2];
    q[3] = c[0] * s[1] * c[2] + s[0] * c[1] * s[2];
    break;
  }

  case EULER_121:
  {
    q[0] = ch * cos(h[0] + h[2]);
    q[1] = ch * sin(h[0] + h[2]);
    q[2] = sh * cos(h[0] - h[2]);
    q[3] = sh * sin(h[0] - h[2]);
    break;
  }

  case EULER_131:
  {
    q[0] = ch * cos(h[0] + h[2]);
    q[1] = ch * sin(h[0] + h[2]);
    q[2] = sh * sin(-h[0] + h[2]);
    q[3] = sh * cos(-h[0] + h[2]);
    break;
  }

  case EULER_213:
  {
    q[0] = c[0] * c[1] * c[2] + s[0] * s[1] * s[2];
    q[1] = c[0] * s[1] * c[2] + s[0] * c[1] * s[2];
    q[2] = s[0] * c[1] * c[2] - c[0] * s[1] * s[2];
    q[3] = c[0] * c[1] * s[2] - s[0] * s[1] * c[2];
    break;
  }

  case EULER_231:
  {
    q[0] = c[0] * c[1] * c[2] - s[0] * s[1] * s[2];
    q[1] = c[0] * c[1] * s[2] + s[0] * s[1] * c[2];
    q[2] = s[0] * c[1] * c[2] + c[0] * s[1] * s[2];
    q[3] = c[0] * s[1] * c[2] - s[0] * c[1] * s[2];
    break;
  }

  case EULER_212:
  {
    q[0] = ch * cos(h[0] + h[2]);
    q[1] = sh * cos(-h[0] + h[2]);
    q[2] = ch * sin(h[0] + h[2]);
    q[3] = sh * sin(-h[0] + h[2]);
    break;
  }

  case EULER_232:
  {
    q[0] = ch * cos(h[0] + h[2]);
    q[1] = sh * sin(h[0] - h[2]);
    q[2] = ch * sin(h[0] + h[2]);
    q[3] = sh * cos(h[0] - h[2]);
    break;
  }

  case EULER_312:
  {
    q[0] = c[0] * c[1] * c[2] - s[0] * s[1] * s[2];
    q[1] = c[0] * s[1] * c[2] - s[0] * c[1] * s[2];
    q[2] = c[0] * c[1] * s[2] + s[0] * s[1] * c[2];
    q[3] = s[0] * c[1] * c[2] + c[0] * s[1] * s[2];
    break;
  }

  case EULER_321:
  {
    q[0] = c[0] * c[1] * c[2] + s[0] * s[1] * s[2];
    q[1] = c[0] * c[1] * s[2] - s[0] * s[1] * c[2];
    q[2] = c[0] * s[1] * c[2] + s[0] * c[1] * s[2];
    q[3] = s[0] * c[1] * c[2] - c[0] * s[1] * s[2];

    break;
  }

  case EULER_313:
  {
    q[0] = ch * cos(h[0] + h[2]);
    q[1] = sh * cos(h[0] - h[2]);
    q[2] = sh * sin(h[0] - h[2]);
    q[3] = ch * sin(h[0] + h[2]);
    break;
  }

  case EULER_323:
  {
    q[0] = ch * cos(h[0] + h[2]);
    q[1] = sh * sin(-h[0] + h[2]);
    q[2] = sh * cos(-h[0] + h[2]);
    q[3] = ch * sin(h[0] + h[2]);
    break;
  }
  }
}

void euler_to_dcm(const double e[3], const euler_seq_t es, double m[3][3])
{
  const double c[3] = {cos(e[0]), cos(e[1]), cos(e[2])};
  const double s[3] = {sin(e[0]), sin(e[1]), sin(e[2])};

  switch (es)
  {
  case EULER_123:
  {
    m[0][0] = c[1] * c[2];
    m[0][1] = c[2] * s[0] * s[1] + c[0] * s[2];
    m[0][2] = s[0] * s[2] - c[0] * c[2] * s[1];
    m[1][0] = -c[1] * s[2];
    m[1][1] = c[0] * c[2] - s[0] * s[1] * s[2];
    m[1][2] = c[2] * s[0] + c[0] * s[1] * s[2];
    m[2][0] = s[1];
    m[2][1] = -c[1] * s[0];
    m[2][2] = c[0] * c[1];
    break;
  }

  case EULER_132:
  {
    m[0][0] = c[1] * c[2];
    m[0][1] = c[0] * c[2] * s[1] + s[0] * s[2];
    m[0][2] = c[2] * s[0] * s[1] - c[0] * s[2];
    m[1][0] = -s[1];
    m[1][1] = c[0] * c[1];
    m[1][2] = c[1] * s[0];
    m[2][0] = c[1] * s[2];
    m[2][1] = -c[2] * s[0] + c[0] * s[1] * s[2];
    m[2][2] = c[0] * c[2] + s[0] * s[1] * s[2];
    break;
  }

  case EULER_121:
  {
    m[0][0] = c[1];
    m[0][1] = s[0] * s[1];
    m[0][2] = -c[0] * s[1];
    m[1][0] = s[1] * s[2];
    m[1][1] = c[0] * c[2] - c[1] * s[0] * s[2];
    m[1][2] = c[2] * s[0] + c[0] * c[1] * s[2];
    m[2][0] = c[2] * s[1];
    m[2][1] = -c[1] * c[2] * s[0] - c[0] * s[2];
    m[2][2] = c[0] * c[1] * c[2] - s[0] * s[2];
    break;
  }

  case EULER_131:
  {
    m[0][0] = c[1];
    m[0][1] = c[0] * s[1];
    m[0][2] = s[0] * s[1];
    m[1][0] = -c[2] * s[1];
    m[1][1] = c[0] * c[1] * c[2] - s[0] * s[2];
    m[1][2] = c[1] * c[2] * s[0] + c[0] * s[2];
    m[2][0] = s[1] * s[2];
    m[2][1] = -c[2] * s[0] - c[0] * c[1] * s[2];
    m[2][2] = c[0] * c[2] - c[1] * s[0] * s[2];
    break;
  }

  case EULER_213:
  {
    m[0][0] = c[0] * c[2] + s[0] * s[1] * s[2];
    m[0][1] = c[1] * s[2];
    m[0][2] = -c[2] * s[0] + c[0] * s[1] * s[2];
    m[1][0] = c[2] * s[0] * s[1] - c[0] * s[2];
    m[1][1] = c[1] * c[2];
    m[1][2] = c[0] * c[2] * s[1] + s[0] * s[2];
    m[2][0] = c[1] * s[0];
    m[2][1] = -s[1];
    m[2][2] = c[0] * c[1];
    break;
  }

  case EULER_231:
  {
    m[0][0] = c[0] * c[1];
    m[0][1] = s[1];
    m[0][2] = -c[1] * s[0];
    m[1][0] = -c[0] * c[2] * s[1] + s[0] * s[2];
    m[1][1] = c[1] * c[2];
    m[1][2] = c[2] * s[0] * s[1] + c[0] * s[2];
    m[2][0] = c[2] * s[0] + c[0] * s[1] * s[2];
    m[2][1] = -c[1] * s[2];
    m[2][2] = c[0] * c[2] - s[0] * s[1] * s[2];
    break;
  }

  case EULER_212:
  {
    m[0][0] = c[0] * c[2] - c[1] * s[0] * s[2];
    m[0][1] = s[1] * s[2];
    m[0][2] = -c[2] * s[0] - c[0] * c[1] * s[2];
    m[1][0] = s[0] * s[1];
    m[1][1] = c[1];
    m[1][2] = c[0] * s[1];
    m[2][0] = c[1] * c[2] * s[0] + c[0] * s[2];
    m[2][1] = -c[2] * s[1];
    m[2][2] = c[0] * c[1] * c[2] - s[0] * s[2];
    break;
  }

  case EULER_232:
  {
    m[0][0] = c[0] * c[1] * c[2] - s[0] * s[2];
    m[0][1] = c[2] * s[1];
    m[0][2] = -c[1] * c[2] * s[0] - c[0] * s[2];
    m[1][0] = -c[0] * s[1];
    m[1][1] = c[1];
    m[1][2] = s[0] * s[1];
    m[2][0] = c[2] * s[0] + c[0] * c[1] * s[2];
    m[2][1] = s[1] * s[2];
    m[2][2] = c[0] * c[2] - c[1] * s[0] * s[2];
    break;
  }

  case EULER_312:
  {
    m[0][0] = c[0] * c[2] - s[0] * s[1] * s[2];
    m[0][1] = c[2] * s[0] + c[0] * s[1] * s[2];
    m[0][2] = -c[1] * s[2];
    m[1][0] = -c[1] * s[0];
    m[1][1] = c[0] * c[1];
    m[1][2] = s[1];
    m[2][0] = c[2] * s[0] * s[1] + c[0] * s[2];
    m[2][1] = s[0] * s[2] - c[0] * c[2] * s[1];
    m[2][2] = c[1] * c[2];
    break;
  }

  case EULER_321:
  {
    m[0][0] = c[1] * c[0];
    m[0][1] = c[1] * s[0];
    m[0][2] = -s[1];
    m[1][0] = s[2] * s[1] * c[0] - c[2] * s[0];
    m[1][1] = s[2] * s[1] * s[0] + c[2] * c[0];
    m[1][2] = s[2] * c[1];
    m[2][0] = c[2] * s[1] * c[0] + s[2] * s[0];
    m[2][1] = c[2] * s[1] * s[0] - s[2] * c[0];
    m[2][2] = c[2] * c[1];
    break;
  }

  case EULER_313:
  {
    m[0][0] = c[2] * c[0] - s[2] * c[1] * s[0];
    m[0][1] = c[2] * s[0] + s[2] * c[1] * c[0];
    m[0][2] = s[2] * s[1];
    m[1][0] = -s[2] * c[0] - c[2] * c[1] * s[0];
    m[1][1] = -s[2] * s[0] + c[2] * c[1] * c[0];
    m[1][2] = c[2] * s[1];
    m[2][0] = s[1] * s[0];
    m[2][1] = -s[1] * c[0];
    m[2][2] = c[1];
    break;
  }

  case EULER_323:
  {
    m[0][0] = c[0] * c[1] * c[2] - s[0] * s[2];
    m[0][1] = c[1] * c[2] * s[0] + c[0] * s[2];
    m[0][2] = -c[2] * s[1];
    m[1][0] = -c[2] * s[0] - c[0] * c[1] * s[2];
    m[1][1] = c[0] * c[2] - c[1] * s[0] * s[2];
    m[1][2] = s[1] * s[2];
    m[2][0] = c[0] * s[1];
    m[2][1] = s[0] * s[1];
    m[2][2] = c[1];
    break;
  }
  }
}

void dcm_to_euler(const double m[3][3], double e[3], const euler_seq_t es)
{
  switch (es)
  {
  case EULER_123:
  {
    e[0] = atan2(-m[2][1], m[2][2]);
    e[1] = asin(m[2][0]);
    e[2] = atan2(-m[1][0], m[0][0]);
    break;
  }

  case EULER_132:
  {
    e[0] = atan2(m[1][2], m[1][1]);
    e[1] = asin(-m[1][0]);
    e[2] = atan2(m[2][0], m[0][0]);
    break;
  }

  case EULER_121:
  {
    e[0] = atan2(m[0][1], -m[0][2]);
    e[1] = acos(m[0][0]);
    e[2] = atan2(m[1][0], m[2][0]);
    break;
  }

  case EULER_131:
  {
    e[0] = atan2(m[0][2], m[0][1]);
    e[1] = acos(m[0][0]);
    e[2] = atan2(m[2][0], -m[1][0]);
    break;
  }

  case EULER_213:
  {
    e[0] = atan2(m[2][0], m[2][2]);
    e[1] = asin(-m[2][1]);
    e[2] = atan2(m[0][1], m[1][1]);
    break;
  }

  case EULER_231:
  {
    e[0] = atan2(-m[0][2], m[0][0]);
    e[1] = asin(m[0][1]);
    e[2] = atan2(-m[2][1], m[1][1]);
    break;
  }

  case EULER_212:
  {
    e[0] = atan2(m[1][0], m[1][2]);
    e[1] = acos(m[1][1]);
    e[2] = atan2(m[0][1], -m[2][1]);
    break;
  }

  case EULER_232:
  {
    e[0] = atan2(m[1][2], -m[1][0]);
    e[1] = acos(m[1][1]);
    e[2] = atan2(m[2][1], m[0][1]);
    break;
  }

  case EULER_312:
  {
    e[0] = atan2(-m[1][0], m[1][1]);
    e[1] = asin(m[1][2]);
    e[2] = atan2(-m[0][2], m[2][2]);
    break;
  }

  case EULER_321:
  {
    e[0] = atan2(m[0][1], m[0][0]);
    e[1] = asin(-m[0][2]);
    e[2] = atan2(m[1][2], m[2][2]);
    break;
  }

  case EULER_313:
  {
    e[0] = atan2(m[2][0], -m[2][1]);
    e[1] = acos(m[2][2]);
    e[2] = atan2(m[0][2], m[1][2]);
    break;
  }

  case EULER_323:
  {
    e[0] = atan2(m[2][1], m[2][0]);
    e[1] = acos(m[2][2]);
    e[2] = atan2(m[1][2], -m[0][2]);
    break;
  }
  }
}
